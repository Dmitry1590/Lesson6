package homework.animals;

public class Cat extends Animal {
//используем наследование с помощью слова "extends"
    //теперь поля переменных можно убрать и метод jump которые есть в классе Animal

      //  private String name;
      //  private String color;
      //  private int age;

    // если понадобится в классе наследнике создать поле (переменную) для своего метода, нельзя использовать название полей родительского класса
    //объяснение в классе Aniimal (выведется null)
    // к методам не относится!

    //введем новую переменную в классе Cat

    protected int liveCount;
    private final int DEFAULT_LIVE_COUNT=9; //перемееная количество жизней (константы обозначаем final)


        //создаем конструктор
    //в классах наследниках конструкторы наследуются от родительского конструктора по умолчанию (в данном случае конструтор Animal()
    //перед созданием конструктора класса обычно вызывают родителский конструктор методом super() но это обычно происходит по умолчанию и не пишут
// однако если в родительском классе конструктор Animal()
        public Cat(String name, String color, int age) {
            super(name, color, age);
           // System.out.println("Cat");
            this.liveCount=DEFAULT_LIVE_COUNT;
            //всегда первой строкой вызов родительский конструктор
        }

       /* //создаем метод (любой)
        public void jump() {
            System.out.println(name + " jump!");
        }*/
// создаем метод количество потребления еды

    public void findFood() {
        System.out.println(name+" findFood...");
    }

    //создаем метод voice название такое же как в родительском классе
    //!!!ВАЖНО спросить у преподавателя, если при вызове метода класс-наследник сначала ищет этот метод в своем теле
    // тогда зачем мы вообще создаем этот метод в родительском классе, по сути до него очередь не доходит.....

    //метод voice на данный момент будет вызываться из класса Cat

  /*  public void voice(){
        System.out.println(name+": meow!");
    }*/
    // если закомментить абстрактный метод, возникнет ошибка, он должен быть вызван в классе наследнике!!! через Alt+Insert "Implement methods"
    //если класс наследник тоже является абстрактным для дугих классов, тогда это не обязательно

    @Override
    public void voice() {

    }



    }
